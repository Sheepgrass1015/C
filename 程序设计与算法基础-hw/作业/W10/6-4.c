/*
本题要求实现一个函数，使得给定的有序数数中的元素都是唯一的（也有人称为去重）。
要求在给定的数组上就地实现（不得利用其它的数组转存）。
函数要求返回唯一化后的数组新长度。
你能否做到每个元素最多移动一次？
*/

//怎么做到呢？我初始的想法是，每遇到一个新的数，就判断它是否在前面出现过
//如果没有——它就留在原地，我的“填充”指针往后移动一格，同时“扫描”指针往后移动一格
//如果有——它就被清零/移动到末尾，然后我的“填充”指针不动，“扫描”指针往后移动一格
int fun (int *D,int N ){
    int cnt=0;//cnt既充当了计数的功能，还是最后的返回值，并且作为“填充”指针
    int flag=1;
    for(int i=0;i<N;i++){//i即作为循环次数，又作为“扫描”指针，因为不论如何，“扫描”指针总是要往后移动的
        flag=1;
        if(i==1){//第二个元素有点特殊，特判一下
            if(*(D+1)==*D){
                flag=0;
            }
        }
        for(int j=0;j<=i-1;j++){
            //printf("D%d=%d D%d=%d\n",i,*(D+i),j,*(D+j));
            if(*(D+j)==*(D+i)){//*(D+j)其实就相当于D[j]
                flag=0;
                break;
            }
        }
        if(flag==1){
            *(D+cnt)=*(D+i);
            cnt++;
        }
    }
    return cnt;
}
