编写一个存放int的链表，链表用以下的数据类型表示：
```c
typedef struct _node Node;

typedef struct {
    Node *head;
    Node *tail;
} List;

```
这个库要提供以下API函数：
```c
List list_create();
void list_free(List *list);

void list_append(List *list, int v);
void list_insert(List *list, int v);

void list_set(List *list, int index, int v);
int list_get(List *list, int index);

int list_size(List *list);

int list_find(List *list, int v);
void list_remove(List *list, int v);

void list_iterate(List *list, void (*func)(int v));

```
- List list_create(); 创建一个List，其中的head和tail都是零。

- void list_free(List *list); 释放整个链表中全部的结点，list的head和tail置零。

- void list_append(List *list, int v); 用v制作新的结点加到链表的最后。

- void list_insert(List *list, int v); 用v制作新的结点加到链表的最前面。

- void list_set(List *list, int index, int v); 将链表中第index个结点的值置为v，链表结点从零开始编号。

- int list_get(List *list, int index); 获得链表中第index个结点的值，第一个结点的index为零。

- int list_size(List *list); 给出链表的大小。

- int list_find(List *list, int v); 在链表中寻找值为v的结点，返回结点的编号，结点的编号从零开始；如果找不到，返回-1。

- void list_remove(List *list, int v); 删除链表中值为v的结点。

- void list_iterate(List *list, void (*func)(int v)); 遍历链表，依次对每一个结点中的值做func函数。
---
你的提交应该在src下有linkedlist.h和linkedlist.c两个文件，Node不能在linkedlist.h中声明。

在本地测试时，如果使用Windows，可以用mingw32-make来执行Makefile完成编译，编译产生的是test.exe，用命令行执行时，必须加命令行参数来指定输出测试结果的文件名，如：

```test 123.txt```

运行过程不会看到任何输出，运行结束后，检查123.txt，其中的内容应该如下：
```
create 1        PASS
create 2        PASS
append 1        PASS
append 2        PASS
insert 1        PASS
insert 2        PASS
size            PASS
get/set         PASS
find random     PASS
find first      PASS
find last       PASS
find not in     PASS
remove random   PASS
remove last     PASS
remove first    PASS
iterate         PASS
free            PASS
20

```